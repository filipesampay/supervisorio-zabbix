            getItemValue(hostid, "prtMarkerSuppliesLevel[Black Toner Cartridge]"),
            getItemValue(hostid, "prtMarkerSuppliesLevel[Cyan Toner Cartridge]"),
            getItemValue(hostid, "prtMarkerSuppliesLevel[Magenta Toner Cartridge]"),
            getItemValue(hostid, "prtMarkerSuppliesLevel[Yellow Toner Cartridge]"),
        ]);
        
        metrics.ink = { black, cyan, magenta, yellow };

    // LÃ³gica PadrÃ£o para Computadores
    } else {
      const [cpu, ram, pingValue, pingAlive] = await Promise.all([
        getItemValue(hostid, "system.cpu.util"),
        getItemValue(hostid, "vm.memory.util"),
        getItemValue(hostid, "icmppingsec"),
        getItemValue(hostid, "icmpping"),
      ]);
      metrics.cpu = cpu || 0;
      metrics.ram = ram || 0;
      metrics.ping = pingValue ? pingValue * 1000 : null;
      metrics.pingAlive = !!(pingAlive && Number(pingAlive) >= 1);
      // MAC serÃ¡ lido do inventÃ¡rio do host (selectInventory)
      metrics.uptimeSec = await getItemValue(hostid, "system.uptime");
      metrics.totalRam = await getItemValue(hostid, "vm.memory.size[total]");
      metrics.totalDisk = await getItemValue(hostid, "vfs.fs.size[C:,total]");
    }

    // Ping do agente para todos os tipos
    const agentPing = await getItemValue(hostid, "agent.ping");
    metrics.agentStatus = agentPing > 0 ? "online" : "offline";
  } catch (err) {
    console.error(`Erro ao buscar mÃ©tricas do host ${hostid}:`, err.message);
  }

  return metrics;
}
// ===================================================================
// ROTAS DE HISTÃ“RICO (SEÃ‡ÃƒO ALTERADA E COM ADIÃ‡Ã•ES)
// ===================================================================

/**
 * FunÃ§Ã£o genÃ©rica para buscar histÃ³rico de um item no Zabbix.
 * @param {string} hostid - ID do host.
 * @param {string} itemKey - Chave do item (ex: "system.cpu.util").
 * @param {number} historyType - Tipo de histÃ³rico no Zabbix (0=float, 3=numÃ©rico).
 * @param {function} valueFormatter - FunÃ§Ã£o para formatar o valor recebido.
 */
async function getZabbixHistory(hostid, itemKey, historyType, valueFormatter = (v) => parseFloat(v)) {
  await ensureAuth();

  // 1. Encontrar o itemid para a chave fornecida
  const itemResp = await axiosInstance.post(ZABBIX_CONFIG.url, {
    jsonrpc: "2.0", method: "item.get",
    params: { output: ["itemid"], hostids: hostid, filter: { key_: itemKey }, limit: 1 },
    auth: zabbixAuthToken, id: 10
  });

  const itemid = itemResp.data.result[0]?.itemid;
  if (!itemid) return []; // Retorna vazio se o item nÃ£o existe

  // 2. Buscar o histÃ³rico para o itemid encontrado
  const now = Math.floor(Date.now() / 1000);
  const dayAgo = now - 86400; // 24 horas atrÃ¡s

  const historyResp = await axiosInstance.post(ZABBIX_CONFIG.url, {
    jsonrpc: "2.0", method: "history.get",
    params: {
      output: "extend", history: historyType, itemids: itemid,
      sortfield: "clock", sortorder: "ASC",
      time_from: dayAgo, time_till: now,
    },
    auth: zabbixAuthToken, id: 11
  });

  // 3. Formatar a saÃ­da
  return historyResp.data.result.map((h) => ({
    time: Number(h.clock),
    value: valueFormatter(h.value),
  }));
}

// Rota de RAM (agora usando a funÃ§Ã£o genÃ©rica)
app.get("/api/history/:hostid/ram", async (req, res) => {
  try {
    const data = await getZabbixHistory(
      req.params.hostid,
      "vm.memory.size[used]",
      3, // NumÃ©rico (bytes)
      (v) => parseFloat(v) / 1024 / 1024 / 1024 // Formata para GB
    );
    res.json(data);
  } catch (err) {
    console.error("Erro ao buscar histÃ³rico de RAM:", err.message);
    res.status(500).json({ error: "Erro ao buscar histÃ³rico de RAM" });
  }
});

// >>> ROTA NOVA PARA CPU <<<
app.get("/api/history/:hostid/cpu", async (req, res) => {
  try {
    const data = await getZabbixHistory(
      req.params.hostid,
      "system.cpu.util",
      0 // Float (%)
    );
    res.json(data);
  } catch (err) {
    console.error("Erro ao buscar histÃ³rico de CPU:", err.message);
    res.status(500).json({ error: "Erro ao buscar histÃ³rico de CPU" });
  }
});

// >>> ROTA NOVA PARA DISCO <<<
app.get("/api/history/:hostid/disk", async (req, res) => {
  try {
    // Assumindo que vocÃª quer o % de uso do disco C:
    const data = await getZabbixHistory(
      req.params.hostid,
      "vfs.fs.size[C:,pused]",
      0 // Float (%)
    );
    res.json(data);
  } catch (err) {
    console.error("Erro ao buscar histÃ³rico de Disco:", err.message);
    res.status(500).json({ error: "Erro ao buscar histÃ³rico de Disco" });
  }
});


// ===================================================================
// ... (COLE AQUI O RESTO DO SEU CÃ“DIGO)
// Rota /api/computers, /api/host/:id, app.listen, etc.
// ...
// ===================================================================

async function processHostsInChunks(hosts, chunkSize = 10) {
  let allResults = [];
  for (let i = 0; i < hosts.length; i += chunkSize) {
    const chunk = hosts.slice(i, i + chunkSize);
    console.log(`ðŸŒ€ Processando lote ${Math.floor(i / chunkSize) + 1} com ${chunk.length} hosts...`);

    const chunkPromises = chunk.map(async (host) => {
      const metrics = await getHostMetrics(host.hostid, host.name);
      const ip = host.interfaces[0]?.ip || "N/A";
      const group = host.groups[0]?.name || "Sem Grupo";
      const status = metrics.pingAlive || metrics.agentStatus === "online" ? "online" : "offline";
      const macFromInventory = host.inventory?.macaddress_a || host.inventory?.macaddress_b || null;

      return {
        id: parseInt(host.hostid),
        name: host.name,
        ip,
        group,
        status,
        ...metrics,
        macAddress: macFromInventory,
        lastUpdate: new Date().toISOString(),
      };
    });

    const settledResults = await Promise.allSettled(chunkPromises);
    
    settledResults.forEach(result => {
        if (result.status === 'fulfilled') {
            allResults.push(result.value);
        } else {
            console.warn(`âš ï¸ Host falhou no processamento:`, result.reason);
        }
    });
  }
  return allResults;
}

app.get("/api/computers", async (req, res) => {
  try {
    const hosts = await getZabbixHosts();
    if (!hosts || hosts.length === 0) {
      return res.json([]);
    }

    console.log(`ðŸ” Iniciando carregamento de mÃ©tricas para ${hosts.length} hosts em lotes...`);

    // Usa a nova funÃ§Ã£o para processar com concorrÃªncia limitada
    const results = await processHostsInChunks(hosts, 10); // Processa 10 hosts por vez

    console.log(`âœ… MÃ©tricas carregadas de ${results.length} hosts`);
    res.json(results);

  } catch (err) {
    console.error("âŒ Erro na rota /api/computers:", err);
    res.status(500).json({ error: "Erro interno ao buscar hosts" });
  }
});

app.get("/api/host/:id", async (req, res) => {
  const { id } = req.params;
  try {
    const hosts = await getZabbixHosts();
    const host = hosts.find((h) => h.hostid === id);
    if (!host) return res.status(404).json({ error: "Host nÃ£o encontrado" });

    const metrics = await getHostMetrics(host.hostid, host.name);

    const ip = host.interfaces[0]?.ip || "N/A";
    const group = host.groups[0]?.name || "Sem Grupo";
    const status =
      metrics.pingAlive || metrics.agentStatus === "online"
        ? "online"
        : "offline";

    const macFromInventory = host.inventory?.macaddress_a || host.inventory?.macaddress_b || null;

    res.json({
      id: parseInt(host.hostid),
      name: host.name,
      ip,
      group,
      status,
      ...metrics,
      macAddress: macFromInventory,
    });
  } catch (err) {
    console.error("Erro ao buscar host:", err);
    res.status(500).json({ error: "Erro interno ao buscar host" });
  }
});

// ===================================================================
// ROTA: Wake on LAN
// ===================================================================
app.post("/api/wol", async (req, res) => {
  try {
    const mac = (req.body?.mac || '').trim();
    // Aceita formatos 00:11:22:33:44:55 ou 00-11-22-33-44-55
    const macOk = /^([0-9A-Fa-f]{2}([:\-])){5}([0-9A-Fa-f]{2})$/.test(mac);
    if (!macOk) {
      return res.status(400).json({ error: 'MAC invÃ¡lido' });
    }

    // Se houver script externo configurado, usa ele
    if (WOL_SCRIPT_PATH) {
      execFile(WOL_SCRIPT_PATH, [mac], { timeout: 8000 }, (err, stdout, stderr) => {
        if (err) {
          console.error('Erro ao executar script WOL:', err.message, stderr);
          return res.status(500).json({ error: 'Falha ao executar script WOL' });
        }
        return res.json({ ok: true, stdout: (stdout || '').toString().trim() });
      });
      return;
    }

    // Fallback: usa biblioteca wake_on_lan
    try {
      if (!wolLib) wolLib = require('wake_on_lan');
    } catch (e) {
      console.error('Biblioteca wake_on_lan nÃ£o disponÃ­vel e sem script externo');
      return res.status(500).json({ error: 'WOL indisponÃ­vel no servidor' });
    }

    wolLib.wake(mac, { address: WOL_BROADCAST }, (err) => {
      if (err) {
